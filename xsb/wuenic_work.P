/* wuenic_ver_3.pl version 3.

Implements WHO & UNICEF rules for estimating national
infant immunization coverage. Includes explanations and
grade of confidence in estimate.

Based on methods described in:

  Burton A, Monash R, Lautenbach B, Gacic-Dobo M, Neill M, Karimov
  R, Wolfson L, Jones G, Birmingham M. WHO and UNICEF estimates of
  national infant immunization coverage: methods and processes.
  Bull World Health Organ 2009; 87:535-541.
  http://www.who.int/bulletin/volumes/87/7/08-053819.pdf

  Burton A, Gacic-Dobo M, Karimov R, Kowalski R.
  A computational logic-based representation of the WHO and UNICEF
  estimates of national immunization coverage. DRAFT 23 January 2011.

  Articles and code available at: http://sites.google.com/site/wuenic/

Author: Tony BURTON
        System Analyst
        Strategic Information Group
        Expanded Pogramme on Immunization
        Department of Immunization, Vaccines, and Biologicals
        World Health Organization
        1211 Geneva 27
        Switzerland
        BurtonA@who.int

depends upon: xsb 3.1 prolog compiler; library: lists, standard.
http://xsb.sourceforge.net/

Created:       6 November 2011.
Last update:   6 May 2016. ipv1 & rcv1 added, GoC for rcv1 based on mcv1 or mcv2 GoC

Naming conventions:
    predicates names: lower_case_underscore_separated
	function names:   lower_case_underscore_separated
    variable names:   InterCaps
    literals:         camelCase

Note that code is constructed "top down" with higher level goals appearing first.
Auxaliarity predicates and utility routines appear at the end of the module.

%TBD: verify meaning of "new vaccine" for modified right handed sawtooth criteria.
%TBD: add assign indirect value for country vaccine year (anchor? wuenic?, both?)
%TBD: Delete (or fix) bubble up GoC.
%TBD: Add green line

working group decisions:	comment
							ignoreGov, acceptGov, *modifyGov,
							ignoreAdmin, acceptAdmin, *modifyAdmin,
							ignoreReported, acceptReported, *modifiyReported,
							ignoreSurvey, acceptSurvey, modifySurvey,
							interpolate, calibrate, *use_reported,
							assignAnchor, assignWUENIC, assignGoC.

Input atomic sentences:
    admin(country,vaccine,year,percent coverage).
    gov(country,vaccine,year,percent coverge).
    legacy(country,vaccine,year,percent coverage).
    survey_results(country,vaccine,year,surveyid,description,percent coverage).
    estimate_required(country,vaccine,year,presentation,comment).
    wgd(country,vaccine,year1,year2,action,explanation1,coverageID1,coverageAssign1,coverageID2,coverageAsign2)
	births_UNPD(country,year,births)
	si_UNPD(country,year,births_surviving_to_age_one)

WHO and UNICEF working group memebers as of 1 January 2010 - 30 April 2012:
        Dr David BROWN, UNICEF/New York (dbrown@unicef.org)
        Mr Tony BURTON, WHO/Geneva  (burtona@who.int)
        Ms Marta GACIC-DOBO, WHO/Geneva  (gacicdobom@who.int)
        Mr Rouslan KARIMOV, UNICEF/NEW YORK (rkarimov@unicef.org)
        Dr Robert KOWALSKI, Imperial College London (r.kowalski@imperial.ac.uk)
 */

% use xsb tabling feature to increases inference time.
% ---------------------------------------------------
:- table anchor_point/6.
:- table survey/5.
:- table reported/5.
:- table wuenic_I/6.

:- op(500,xfy,:).


:- import member/2 from lists.
:- import length/2 from lists.
:- import sum_list/2 from lists.
:- import concat_atom/2 from string.
:- import between/3 from basics.

% sawtooth_threshold : difference in increase/decrease between Y+/-1 and Y in reported data
% survey_reported_threshold : differerence between survey results and reported data.
% reported_calibrated_threshold : if mixed anchor points swithc between using reported and calibarated.
% -----------------------------------------------------------------------------------------------------
sawtooth_threshold(10).
survey_reported_threshold(10).
confidence_survey_scope(2).
confidence_survey_threshold(10).
confidence_UNPD_threshold(10).

% establish relationship between name of first and third dose of vaccine.
% used in estimating recall bias.
% ------------------------------
vaccine(dtp3,dtp1).
vaccine(pol3,pol1).
vaccine(hib3,hib1).
vaccine(hepb3,hepb1).
vaccine(pcv3,pcv1).

% Load country-specific predicates describing data, survey_results,
% working group decisions and whether an estimate is required.
% :- multifile admin/4.
% :- multifile gov/4.
% :- multifile vaccinated/4.
% :- multifile target/4.
% :- multifile legacy/4.
% :- multifile survey_results/6.
% :- multifile wgd/10.
% :- multifile births_UNPD/3.
% :- multifile si_UNPD/4.
% :- multifile firstRubellaAtSecondMCV/4.

% First rubella given with second measles dose (see country-specific
% files for other options)
firstRubellaAtSecondMCV(_C, rcv1, _Y, mcv2).

% ==================================================
% top level predicate. Creates and outputs estimates.
% ==================================================
estimate :-

	% Unify country code, country name and date for output.
	% ----------------------------------------------------
	country(CountryCode,CountryName),
	date(Date),

	% Collect the set of all final estimates in list Estimate.
      % -------------------------------------------------------
	setof([
		CountryName,
		Date,
		CountryCode,
		Vaccine,
		Year,
		Coverage,
		PrevRev,
		GC,
		Admin,
		Gov,
		Reported,
		Vaccinated,
		Target,
		UnpdBirths,
		UnpdSI,
		SeriesValue,
		Source,
		SurveyInfo,
		Rule,
		Explanation],

	   wuenic(
		CountryCode,
		Vaccine,
		Year,
		Rule,
		Explanation,
		Coverage,
		PrevRev,
		GC,
		Admin,
		Gov,
		Reported,
		Vaccinated,
		Target,
		UnpdBirths,
		UnpdSI,
		Source,
		SeriesValue,
		SurveyInfo),

		Estimates),

	open_out_file(OutFile,'wuenic.out',	'Country\tProductionDate\tISOCountryCode\tVaccine\tYear\tWUENIC\tWUENICPreviousRevision\tGradeOfConfidence\tAdministrativeCoverage\tGovernmentEstimate\tReportedCoverage\tChildrenVaccinated\tChildrenInTarget\tBirthsUNPD\tSurvivingInfantsUNPD\tReportedTimeSeries\tReportedTimeSeriesSource\tSurveyInformation\tRule\tComment\t'),
	output_results(Estimates,OutFile), close(OutFile).

% Final estimate where there are wuenic values
% --------------------------------------------
wuenic(C,V,Y,Rule,Explanation,Coverage,Prev,GC,Admin,Gov,Reported,Vaccinated,Target,Births,SI,Source,Series,Survey) :-
	estimate_required(C,V,Y,_,_),
	wuenic_I(C,V,Y,Rule,Explain,Cov),
	bound_0_100(Cov,Coverage),
	assign_Grade_of_Confidence(C,V,Y,Rule,Coverage,GoCExplanation,GC),
	%assign_GoC(C,V,Y,Rule,Coverage,GoCExplanation,GC),
	collect_data(C, V, Y,
	    Prev, Admin, Gov, Reported, Vaccinated, Target, Births, SI, Series, Source, Survey),
	change_from_previous_revision(C,V,Y,Coverage,Change),
	collect_explanations(C, V, Y, Text),
	concat_atom([Explain, ' ', Text, ' ', Change, ' ', GoCExplanation], Explanation).

% ------------------------------------------------------------------------------
%  End of wuenic top level routine.

	assign_Grade_of_Confidence(C,V,Y,Rule,Coverage,GoCExplanation,GC) :-
		not(member(V,['rcv1'])),
		assign_GoC(C,V,Y,Rule,Coverage,GoCExplanation,GC).

	% MG: Copy rcv1 from mcv1
	assign_Grade_of_Confidence(C,rcv1,Y,Rule,Coverage,GoCExplanation,GC) :-
		estimate_required(C,rcv1,Y,_,na),
		assign_GoC(C,mcv1,Y,Rule,Coverage,GoCExplanation,GC).

	% MG: Copy rcv1 from mcv2
	assign_Grade_of_Confidence(C,rcv1,Y,Rule,Coverage,GoCExplanation,GC) :-
		estimate_required(C,rcv1,Y,_,mcv2),
		assign_GoC(C,mcv2,Y,Rule,Coverage,GoCExplanation,GC).

	% GoC = 1 is low confidence (1 star), GoC = 3 is high confidence (3 stars) - modified 4 July 2016 TB
	% --------------------------------------------------------------------------------------------------
	assign_GoC(C,V,Y,Rule,Coverage,Support,'3') :- three_stars(C,V,Y,Rule,Coverage,Support),not(workingGroupDecision(C,V,Y,assignGoC,_,_,_)).
	assign_GoC(C,V,Y,Rule,_Coverage,Support,'2') :- two_stars(C,V,Y,Rule,Support),not(workingGroupDecision(C,V,Y,assignGoC,_,_,_)).
	assign_GoC(C,V,Y,Rule,Coverage,Support,'1') :- challenge(C,V,Y,Rule,Coverage,_),
												   setof(Evidence,challenge(C,V,Y,Rule,Coverage,Evidence),List),
												   concat_atom(['Estimate challenged by: ',List],Support),
												   not(workingGroupDecision(C,V,Y,assignGoC,_,_,_)).

	assign_GoC(C,V,Y,Rule,Coverage,Support,'1') :- no_data(C,V,Y,Rule,Coverage,Support),not(workingGroupDecision(C,V,Y,assignGoC,_,_,_)).
	assign_GoC(C,V,Y,_Rule,_,Support,GC) :- workingGroupDecision(C,V,Y,assignGoC,Explanation,_,GC),
												   concat_atom(['GoC=Assigned by working group. ',Explanation],Support).

	% Supported by reported data, survey and denominator
	% --------------------------------------------------
	three_stars(C,V,Y,Rule,_Coverage,'GoC=R+ S+ D+') :- % MG, todo: three_stars does not return Coverage
		goc_reported_condition(C,V,Y,Rule,'R+'),
		goc_survey_condition(C,V,Y,Rule,'S+'),
		goc_denominator_condition(C,V,Y,'D+').

		goc_reported_condition(C,V,Y,_Rule,'R+') :- % MG, todo: Rule = R?
			reported(C,V,Y,_,_),
			wuenic_I(C,V,Y,R,_,_),
			member(R,['R:','R: AP']).

		goc_reported_condition(C,V,Y,_Rule,'R-') :- % see above
			reported(C,V,Y,_,_),
			wuenic_I(C,V,Y,R,_,_),
			not(member(R,['R:','R: AP'])).

		goc_survey_condition(C,V,Y,Rule,'S+') :-
			supporting_survey_in_scope(C,V,Y,Rule),
			not(challenging_survey_in_scope(C,V,Y)).

		goc_survey_condition(C,V,Y,_,'S-') :-
			challenging_survey_in_scope(C,V,Y).

%  simplify previous rule to.
%			supporting_survey_in_scope(C,V,Y,Rule) :-
%				survey(C,V,Y,_,_),
%				wuenic_I(C,V,Y,'S: AP',_,_).

% rewrite rule to look at relationship between estimate rule and
% surveys in scope rule rather than difference in COV and SurveyCoverage
%
			supporting_survey_in_scope(C,V,Y,_) :-
				estimate_required(C,V,SurveyYear,_,_),
				survey(C,V,SurveyYear,_,SurveyCoverage),
				confidence_survey_scope(Scope),
				abs(Y - SurveyYear) =< Scope,
				confidence_survey_threshold(Threshold),
				wuenic_I(C,V,Y,_,_Explanation,Cov),
				abs(Cov - SurveyCoverage) =< Threshold.

% rewrite to look for surveys that challenge surveys.
% Modified 2017-05-05 Burton
%
			challenging_survey_in_scope(C,V,Y) :-
				estimate_required(C,V,SurveyYear,_,_),
				survey(C,V,SurveyYear,_,SurveyCoverage),
				confidence_survey_scope(Scope),
				abs(Y - SurveyYear) =< Scope,
				confidence_survey_threshold(Threshold),
				wuenic_I(C,V,Y,_,_Explanation,Cov),
				abs(Cov - SurveyCoverage) > Threshold.

		goc_denominator_condition(C,V,Y,'D+') :-
			goc_unpd_recal(C,V,Y),
			recal_unpd(C,V,Y,CovRec),
			confidence_UNPD_threshold(Threshold),
			wuenic_I(C,V,Y,_Rule,_Explain,Coverage),
			abs(Coverage - CovRec) < Threshold.
		goc_denominator_condition(C,V,Y,'D-') :-
			goc_unpd_recal(C,V,Y),
			recal_unpd(C,V,Y,CovRec),
			confidence_UNPD_threshold(Threshold),
			wuenic_I(C,V,Y,_Rule,_Explain,Coverage),
			abs(Coverage - CovRec) >= Threshold.

			% Ensure unpd data exist.
			% ------------------------
			goc_unpd_recal(C,V,Y) :- vaccinated(C,V,Y,_), births_UNPD(C,Y,_), si_UNPD(C,Y,_).

			% Recalculate coverage using reported number of children vaccinated
			% and births and surviving infants from UNPD estimates.
			% Births used for bcg and hepb birth dose, surviving infants
			% for remaining vaccines.
			% ------------------------
			recal_unpd(C,V,Y,CovRec) :-
				member(V,['bcg','hepbb']),
				vaccinated(C,V,Y,Vaccinated),
				births_UNPD(C,Y,Births),
				CovRec is Vaccinated / Births * 100.
				% correction of calculation for larger integers old statement = CovRec is Vaccinated * 100 / Births.
			recal_unpd(C,V,Y,CovRec) :-
				member(V,['dtp1','dtp3','pol3','ipv1','mcv1','mcv2','rcv1','hepb3','hib3','rotac','pcv3','yfv']),
				vaccinated(C,V,Y,Vaccinated),
				si_UNPD(C,Y,SI),
				CovRec is Vaccinated / SI * 100.
				% correction of calculation for larger integers old statement = CovRec is Vaccinated * 100 / SI.

	two_stars(C,V,Y,Rule,Support) :-
		(two_sources(C,V,Y,Rule,Support);
		one_source(C,V,Y,Rule,Support)),
		not(three_stars(C,V,Y,_,_,_)),
		not(challenge(C,V,Y,_,_,_)).

	% Supported by two data sources, no challenge
	% --------------------------------------------
	two_sources(C,V,Y,Rule,'GoC=R+ S+') :-
		goc_reported_condition(C,V,Y,Rule,'R+'),
		goc_survey_condition(C,V,Y,Rule,'S+').
	two_sources(C,V,Y,Rule,'GoC=S+ D+') :-
		goc_survey_condition(C,V,Y,Rule,'S+'),
		goc_denominator_condition(C,V,Y,'D+').
	two_sources(C,V,Y,Rule,'GoC=R+ D+') :-
		goc_reported_condition(C,V,Y,Rule,'R+'),
		goc_denominator_condition(C,V,Y,'D+').

	% Supported by single source, no challenge
	% -------------------------------------
	one_source(C,V,Y,Rule,'GoC=R+') :-
		not(two_sources(C,V,Y,_,_)),
		goc_reported_condition(C,V,Y,Rule,'R+').
	one_source(C,V,Y,Rule,'GoC=S+') :-
		not(two_sources(C,V,Y,_,_)),
		goc_survey_condition(C,V,Y,Rule,'S+').
	one_source(C,V,Y,_Rule,'GoC=D+') :-
		not(two_sources(C,V,Y,_,_)),
		goc_denominator_condition(C,V,Y,'D+').

	% Empirical evidence challenges estimate.
	% --------------------------------------
	challenge(C,V,Y,Rule,_Coverage,Condition) :-
		(goc_reported_condition(C,V,Y,Rule,'R-'),Condition = 'R-');
		(goc_survey_condition(C,V,Y,Rule,'S-'),Condition = 'S-');
		(goc_denominator_condition(C,V,Y,'D-'),Condition = 'D-').

	% No empirical supporting evidence.
	% --------------------------------
	no_data(C,V,Y,_Rule,_Coverage,'GoC=No accepted empirical data') :-
		not(goc_reported_condition(C,V,Y,_,_)),
		not(goc_survey_condition(C,V,Y,_,_)),
		not(goc_denominator_condition(C,V,Y,_)).

	change_from_previous_revision(C,V,Y,Coverage,'') :-
		legacy(C,V,Y,PreviousCoverage),
		PreviousCoverage = Coverage.

	change_from_previous_revision(C,V,Y,Coverage,Change) :-
		legacy(C,V,Y,PreviousCoverage),
		not(PreviousCoverage = Coverage),
		concat_atom(['Estimate of ',Coverage,' percent changed from previous revision value of ',PreviousCoverage,' percent. '],Change).

	change_from_previous_revision(C,V,Y,_,'') :-
		not(legacy(C,V,Y,_)).

% Estimate assigned by working group.
wuenic_I(C, V, Y, Rule, Expl, Coverage) :-
    workingGroupDecision(C, V, Y, assignWUENIC, Expl0, _, Cov0),
    !,
    Rule = 'W:',
    Expl = Expl0,
    Coverage = Cov0.

% Estimate for DTP1 > DTP3
wuenic_I(C, dtp1, Y, Rule, Expl, Coverage) :-
    wuenic_II(C, dtp1, Y, _Rule, _Expl, Cov0),
    wuenic_II(C, dtp3, Y, _, _, DTP3),
    DTP3 > Cov0,
    !,
    Rule = 'RMF:',
    concat_atom(['DTP1 coverage estimated based on DTP3 coverage of ', DTP3, '. '], Expl),
    Coverage is round(DTP3 - 0.0058 * DTP3 * DTP3 + 0.3912 * DTP3 + 18.258).

% Estimate for DTP1 plausible
wuenic_I(C, dtp1, Y, Rule, Expl, Coverage) :-
    wuenic_II(C, dtp1, Y, Rule0, Expl0, Cov0),
    !,
    Rule = Rule0,
    Expl = Expl0,
    Coverage = Cov0.

% If DTP1 not reported: RMF
wuenic_I(C, dtp1, Y, Rule, Expl, Coverage) :-
    wuenic_II(C, dtp3, Y, _, _, DTP3),
    !,
    Rule = 'RMF:',
    concat_atom(['DTP1 coverage estimated based on DTP3 coverage of ', DTP3, '. '], Expl),
    Coverage is round(DTP3 - 0.0058 * DTP3 * DTP3 + 0.3912 * DTP3 + 18.258).

% Estimate for RCV1 where RCV1 given at MCV2
wuenic_I(C, rcv1, Y, Rule, Expl, Coverage) :-
    estimate_required(C, rcv1, Y, _, FirstRubellaDose),
    firstRubellaAtSecondMCV(C, rcv1, Y, FirstRubellaDose),
    !,
    wuenic_II(C, mcv2, Y, Rule, _, Coverage),
    Expl = 'First dose of rubella vaccine given with second dose of measles containing vaccine. Estimate based on MCV2 estimate'.

% Estimate for RCV1 where RCV1 given at MCV1
wuenic_I(C, rcv1, Y, Rule, Expl, Coverage) :-
%    estimate_required(C, rcv1, Y, _, FirstRubellaDose),
%    not(firstRubellaAtSecondMCV(C, rcv1, Y, FirstRubellaDose)),
    !,
    wuenic_II(C, mcv1, Y, Rule, _, Coverage),
    Expl = 'Estimate based on estimated MCV1. '.

% Estimate for non-DTP1 & RCV1 vaccines.
wuenic_I(C, V, Y, Rule, Expl, Coverage) :-
    !,
    wuenic_II(C, V, Y, Rule, Expl, Coverage).

% Otherwise, fail
wuenic_I(_C, _V, _Y, _Rule, _Expl, _Coverage) :-
    fail.
    % throw(misc_error(wuenic_I(C, V, Y, Rule, Expl, Coverage))).

% Preliminary estimates
%
% Interpolation forced by working group: todo: should be wuenic_I
wuenic_II(C, V, Y, Rule, Expl, Coverage) :-
    workingGroupDecision(C, V, Y, interpolate, Expl0, _, _),
    !,
    Rule = 'W-I:',
    between_anchor_points(C, V, Y, Before, _, CovBefore, After, _, CovAfter),
    concat_atom(['Estimate informed by interpolation between ', Before,
		 ' and ', After, ' levels. ', Expl0], Expl),
    interpolate(Before, CovBefore, After, CovAfter, Y, Coverage).

% Estimate at anchor points
wuenic_II(C, V, Y, Rule, Expl, Coverage) :-
    anchor_point(C, V, Y, Rule0, Expl0, Cov0),
    !,
    Rule = Rule0,
    Expl = Expl0,
    Coverage = Cov0.

% Estimate between anchor points: between two reported anchors
wuenic_II(C, V, Y, Rule, Expl, Coverage) :-
    reported_time_series(C, V, Y, Source, Cov0),
    member(Source, [gov, admin, interpolated]),
    between_anchor_points(C, V, Y, _, 'R: AP', _, _, 'R: AP', _),
    % todo: check if next line is needed (check at to wuenic_I?)
    % not(workingGroupDecision(C, V, Y, calibrate, _, _, _)),
    !,
    Rule = 'R:',
    member(Source-Expl,
      [ gov-'Estimate informed by reported data. ',
	admin-'Estimate informed by reported administrative data. ',
	interpolated-'Estimate informed by interpolation between reported data. '
      ]),
    Coverage = Cov0.

% Estimate between anchor points: calibrated
wuenic_II(C, V, Y, Rule, Expl, Coverage) :-
    reported_time_series(C, V, Y, _, _),
    between_anchor_points(C, V, Y, Before, RuleBefore, _, After, RuleAfter, _),
    ( RuleBefore \= 'R: AP' ; RuleAfter \= 'R: AP' ),
    !,
    Rule = 'C:',
    concat_atom(['Reported data calibrated to ', Before,
		 ' and ', After, ' levels. '], Expl),
    calibrate(C, V, Before, After, Y, Coverage).

% Estimate before earliest anchor: reported
wuenic_II(C, V, Y, Rule, Expl, Coverage) :-
    reported_time_series(C, V, Y, Source, Cov0),
    member(Source, [admin, gov, interpolated, extrapolated]),
    not(prec_anchor_point(C, V, Y, _, _, _)),
    anchor_point(C, V, AnchorYear, AnchorRule, _, _),
    AnchorRule = 'R: AP',
    AnchorYear > Y,
    not(prec_anchor_point(C, V, AnchorYear, _, _, _)),
    !,
    Rule = 'R:',
    member(Source-Expl,
      [ gov-'Estimate informed by reported data. ',
	admin-'Estimate informed by reported data. ',
	interpolated-'Estimate informed by interpolation between reported data. ',
	extrapolated-'Estimate based on extrapolation from data reported by national government. '
      ]),
    Coverage = Cov0.

% Estimate before earliest anchor: calibrated
wuenic_II(C, V, Y, Rule, Expl, Coverage) :-
    reported_time_series(C, V, Y, _, Reported),
    not(prec_anchor_point(C, V, Y, _, _, _)),
    anchor_point(C, V, AnchorYear, AnchorRule, _, AnchorCoverage),
    AnchorRule \= 'R: AP',
    AnchorYear > Y,
    not(prec_anchor_point(C, V, AnchorYear, _, _, _)),
    !,
    Rule = 'C:',
    concat_atom(['Reported data calibrated to ', AnchorYear, ' levels. '], Expl),
    reported_time_series(C, V, AnchorYear, _, ReportedCoverageAtAnchor),
    Adj is AnchorCoverage - ReportedCoverageAtAnchor,
    Coverage is round(Reported + Adj).

% Estimate after latest anchor: reported
wuenic_II(C, V, Y, Rule, Expl, Coverage) :-
    reported_time_series(C, V, Y, Source, Cov0),
    member(Source, [gov, admin, interpolated, extrapolated]),
    not(succ_anchor_point(C, V, Y, _, _, _)),
    anchor_point(C, V, AnchorYear, AnchorRule, _, _),
    AnchorRule = 'R: AP',
    AnchorYear < Y,
    not(succ_anchor_point(C, V, AnchorYear, _, _, _)),
    !,
    Rule = 'R:',
    member(Source-Expl,
      [ gov-'Estimate informed by reported data.',
	admin-'Estimate informed by reported administrative data. ',
	interpolated-'Estimate informed by interpolation between reported data. ',
	extrapolated-'Estimate based on extrapolation from data reported by national government. '
      ]),
    Coverage = Cov0.

% Estimate after latest anchor: calibrated
wuenic_II(C, V, Y, Rule, Expl, Coverage) :-
    reported_time_series(C, V, Y, _, Cov0),
    not(succ_anchor_point(C, V, Y, _, _, _)),
    anchor_point(C, V, AnchorYear, AnchorRule, _, AnchorCoverage),
    AnchorRule \= 'R: AP',
    AnchorYear < Y,
    not(succ_anchor_point(C, V, AnchorYear, _, _, _)),
    !,
    Rule = 'C:',
    concat_atom(['Reported data calibrated to ', AnchorYear, ' levels.'], Expl),
    reported_time_series(C, V, AnchorYear, _, ReportedCoverageAtAnchor),
    Adj is AnchorCoverage - ReportedCoverageAtAnchor,
    Coverage is round(Cov0 + Adj).

% No anchor points for any year
wuenic_II(C, V, Y, Rule, Expl, Coverage) :-
    reported_time_series(C, V, Y, Source, Cov0),
    not(prec_anchor_point(C, V, Y, _, _, _)),
    not(succ_anchor_point(C, V, Y, _, _, _)),
    !,
    Rule = 'R:',
    member(Source-Expl,
      [ gov-'Estimate informed by reported data. ',
	admin-'Estimate informed by reported administrative data. ',
	interpolated-'Estimate based on interpolation between reported values. ',
	extrapolated-'Estimate informed by extrapolation from reported data. '
      ]),
    Coverage = Cov0.

% Determine coverage value at anchor points defined as years where there
% are multiple data points (reported | survey | wgd).
%
% Reported (gov, admin, extrapolated, interpolated) supported by survey.
% Reported, not supported by survey.
% Reported value "anchored" by working group.
% Working group assigns anchor point value.
%
% semidet, because it is used for search in wuenic_II
%
% Survey results support reported
anchor_point(C, V, Y, 'R: AP', Expl, Coverage) :-
    reported_time_series(C, V, Y, Source, Coverage),
    not(workingGroupDecision(C, V, Y, assignAnchor, _, _, _)),
    survey(C, V, Y, Expl0, SurveyCoverage),
    survey_reported_threshold(Threshold),
    abs(Coverage - SurveyCoverage) =< Threshold,
    member(Source-Expl1,
      [ gov-'Estimate informed by reported data supported by survey. ',
	admin-'Estimate informed by reported administrative data supported by survey. ',
	interpolated-'Estimate informed by interpolation between reported data supported by survey. ',
	extrapolated-'Estimate based on extrapolation from data reported by national government supported by survey. '
      ]),
    concat_atom([Expl1, Expl0], Expl).

% Survey results challenge reported
anchor_point(C, V, Y, 'S: AP', Expl, Coverage) :-
    reported_time_series(C, V, Y, _, ReportedCoverage),
    not(workingGroupDecision(C, V, Y, assignAnchor, _, _, _)),
    survey(C, V, Y, Expl0, Coverage),
    survey_reported_threshold(Threshold),
    abs(ReportedCoverage - Coverage) > Threshold,
    concat_atom(['Survey evidence does not support reported data. Estimate based on survey results. ',
		 Expl0, ' '], Expl).

% Anchor point value set to reported value by working group
anchor_point(C, V, Y, 'R: AP', Expl, Coverage) :-
    reported_time_series(C, V, Y, _, Coverage),
    workingGroupDecision(C, V, Y, assignAnchor, Expl, _, Coverage).

% Anchor point value NOT set to reported value by working group
anchor_point(C, V, Y, 'W: AP', Expl, Assigned) :-
    reported_time_series(C, V, Y, _, Coverage),
    workingGroupDecision(C, V, Y, assignAnchor, Expl0, _, Assigned),
    Coverage \= Assigned,
    concat_atom(['Estimate of ', Assigned, ' percent assigned by working group. ',
		 Expl0], Expl).

% ==============================================
% Level one processing:
%
%   Review data reported by national authorities
%   and survey results. Reported and survey data
%   are accepted, ignored, or modified. Modified
%   data are accepted in the modified form.
% ==============================================

% Final survey information. If multiple survey in the
% same year, accepted and modified results are averaged.
% ----------------------------------
survey(C, V, Y, Expl, Coverage) :-
%   bagof(Cov,survey_accepted(C,V,Y,_,_,Cov),CoverageList),
%   bagof(Cov,SID^survey_accepted(C,V,Y,SID,Cov),CoverageList),
    findall(Cov, survey_accepted(C, V, Y, _, Cov), CoverageList),
    length(CoverageList, N),
    N >= 1,
    sum_list(CoverageList,SumCov),
    Coverage is round(SumCov / N),
    concat_atom(['Survey evidence of ', Coverage, ' percent based on ',
		 N, ' survey(s). '], Expl).

% Unmodified survey results accpeted.
%
% semidet, because multiple surveys are averaged
survey_accepted(C, V, Y, ID, Coverage) :-
    survey_results_for_analysis(C, V, Y, ID, _, Coverage),
    not(survey_reason_to_exclude(C, V, Y, ID, _)),
    not(survey_results_modified(C, V, Y, ID, _, _)).

% Modified survey results accepted.
survey_accepted(C, V, Y, ID, Coverage) :-
    survey_results_for_analysis(C, V, Y, ID, _, _),
    not(survey_reason_to_exclude(C, V, Y, ID, _)),
    survey_results_modified(C, V, Y, ID, _, Coverage).

% Survey results modified for recall bias.
% ---------------------------------------
survey_results_modified(C, V, Y, ID, Expl, Coverage) :-
    member(V, [dtp3, pol3, hib3, hepb3, pcv3]),

    % Third dose, card only
    survey_results(C, V, Y, ID, DescriptionCard3Dose, C3Cov),
    member(confirm:card, DescriptionCard3Dose),
    member(age:AgeCohortCard3Dose, DescriptionCard3Dose),
    member(AgeCohortCard3Dose, ['12-23 m', '18-29 m', '15-26 m', '24-35 m']),

    % First dose, card or history
    vaccine(V, First),
    survey_results(C, First, Y, ID, DescriptionCoH1Dose, CoH1Cov),
    member(confirm:'card or history', DescriptionCoH1Dose),
    member(age:AgeCohortCoH1, DescriptionCoH1Dose),
    member(AgeCohortCoH1, ['12-23 m', '18-29 m', '15-26 m', '24-35 m']),

    % First dose, card only
    survey_results(C, First, Y, ID, DescriptionCard1Dose, C1Cov),
    C1Cov > 0,
    member(confirm:card, DescriptionCard1Dose),
    member(age:AgeCohortCard1Dose, DescriptionCard1Dose),
    member(AgeCohortCard1Dose, ['12-23 m', '18-29 m', '15-26 m', '24-35 m']),

    Adj is C3Cov / C1Cov,
    ThirdHistoryAdj is (CoH1Cov - C1Cov) * Adj,
    CovAdjusted is C3Cov + ThirdHistoryAdj,
    bound_0_100(CovAdjusted, Cov0),

    survey_results_for_analysis(C, V, Y, ID, Description, SurveyCoverage),
    Cov0 \= SurveyCoverage,

    SurveyCovRounded is round(SurveyCoverage),
    CH1 is round(CoH1Cov),
    C1 is round(C1Cov),
    C3 is round(C3Cov),
    member(title:Title, Description),
    concat_atom([Title, ' card or history results of ', SurveyCovRounded,
		 ' percent modifed for recall bias to ', Cov0,
		 ' percent based on 1st dose card or history coverage of ',
		 CH1, ' percent, 1st dose card only coverage of ',
		 C1, ' percent and 3rd dose card only coverage of ',
		 C3, ' percent. '], Expl),
    Coverage = Cov0.

% -------------------------------------------------
% Survey results accepted if no reason to exclude.
%
% Reasons to exclude a survey include:
%    Sample size < 300,
%    The working group decides to exclude the survey.
%
% semidet because of collect_explanations
survey_reason_to_exclude(C, V, Y, ID, Expl) :-
    survey_results_for_analysis(C, V, Y, ID, Description, _),
    not(workingGroupDecision(C, V, Y, acceptSurvey, Expl, ID, _)),
    member(ss:Size, Description),
    Size < 300,
%   !,
    concat_atom(['Survey results ignored. Sample size ', Size,
		 ' less than 300. '], Expl).

survey_reason_to_exclude(C, V, Y, ID, Expl) :-
    survey_results_for_analysis(C, V, Y, ID, Description, _),
    (	workingGroupDecision(C, V, Y, ignoreSurvey, Expl0, ID, _)
    ;	workingGroupDecision(C, V, Y, ignoreSurvey, Expl0, na, _)
    ),
    member(title:Title, Description),
%   !,
    concat_atom([Title, ' results ignored by working group. ', Expl0], Expl).

% Survey results passed for inclusion in the analysis include:
% card or history results for cohorts 12-23, 18-29, 15-26, 24-35 months
% of age
survey_results_for_analysis(C, V, Y, ID, Description, Coverage) :-
    survey_results(C, V, Y, ID, Description, Coverage),
    member(confirm:'card or history', Description),
    member(age:AgeCohort, Description),
    member(AgeCohort, ['12-23 m', '18-29 m', '15-26 m', '24-35 m']).

% =============================================
% Create complete time series of reported data.
%
% So far, semi-deterministic, i.e., no cuts allowed. Needed by
% anchor_point for search.
%
% Reported data.
reported_time_series(C, V, Y, Source, Coverage) :-
    estimate_required(C, V, Y, _, _),
    reported(C, V, Y, Source0, Cov0),
    not(reported_reason_to_exclude(C, V, Y, _, _)),
%    !,
    Source = Source0,
    Coverage = Cov0.

% Interpolation, reported data excluded between two years
reported_time_series(C, V, Y, Source, Coverage) :-
    estimate_required(C, V, Y, _, _),
    reported(C, V, Y, _, _),
    once(reported_reason_to_exclude(C, V, Y, _, _)),
    year_between_reported(C, V, Y, Before, CovBefore, After, CovAfter),
%    !,
    Source = interpolated,
    interpolate(Before, CovBefore, After, CovAfter, Y, Coverage).

% Interpolation, no reported data between two years
reported_time_series(C, V, Y, Source, Coverage) :-
    estimate_required(C, V, Y, _, _),
    not(reported(C, V, Y, _, _)),
    year_between_reported(C, V, Y, Before, CovBefore, After, CovAfter),
%    !,
    Source = interpolated,
    interpolate(Before, CovBefore, After, CovAfter, Y, Coverage).

% Extrapolation, latest required estimate excluded
reported_time_series(C, V, Y, Source, Coverage) :-
    estimate_required(C, V, Y, _, _),
    reported(C, V, Y, _, _),
    once(reported_reason_to_exclude(C, V, Y, _, _)),
	not(year_between_reported(C,V,Y,_,_,_,_)),
    nearest_reported(C, V, Y, _Year, Cov0),
%    !,
    Source = extrapolated,
    Coverage = Cov0.

% Extrapolation, no reported data for year beyond earliest / latest
% required estimate
reported_time_series(C, V, Y, Source, Coverage) :-
    estimate_required(C, V, Y, _, _),
    not(reported(C, V, Y, _, _)),
	not(year_between_reported(C,V,Y,_,_,_,_)),
    nearest_reported(C, V, Y, _Year, Cov0),
%    !,
    Source = extrapolated,
    Coverage = Cov0.

% Reasons to exclude reported data are:
%  1. Working group decision.
%  2. Coverage > 100%
%  3. Inconsistent temporal changes (sawtooth or sudden change most
%  recent year)
%
%  semidet, needed for collect_explanations
reported_reason_to_exclude(C, V, Y, Reason, Expl) :-
    reported(C, V, Y, _, _),
    workingGroupDecision(C, V, Y, ignoreReported, Expl0, _, _),
%    !,
    Reason = wdg,
    concat_atom(['Reported data excluded. ', Expl0], Expl).

reported_reason_to_exclude(C, V, Y, Reason, Expl) :-
    reported(C, V, Y, _, Coverage),
    not(workingGroupDecision(C, V, Y, acceptReported, _, _, _)),
    Coverage > 100,
%    !,
    Reason = 100,
    concat_atom(['Reported data excluded because ', Coverage,
		 ' percent greater than 100 percent. '], Expl).

reported_reason_to_exclude(C, V, Y, Reason, Expl) :-
    reported(C, V, Y, _, Coverage),
    not(workingGroupDecision(C, V, Y, acceptReported, _, _, _)),
    Prec is Y - 1,
    Succ is Y + 1,
    reported(C, V, Prec, _, CoveragePrec),
    reported(C, V, Succ, _, CoverageSucc),
    sawtooth_threshold(Threshold),
    Coverage - CoveragePrec > Threshold,
    Coverage - CoverageSucc > Threshold,
%    !,
    Reason = sawtooth,
    concat_atom(['Reported data excluded due to an increase from ',
		 CoveragePrec, ' percent to ', Coverage,
		 ' percent with decrease ', CoverageSucc, ' percent. '], Expl).

reported_reason_to_exclude(C, V, Y, Reason, Expl) :-
    reported(C, V, Y, _, Coverage),
    not(workingGroupDecision(C, V, Y, acceptReported, _, _, _)),
    Prec is Y - 1,
    Succ is Y + 1,
    reported(C, V, Prec, _, CoveragePrec),
    reported(C, V, Succ, _, CoverageSucc),
    sawtooth_threshold(Threshold),
    CoveragePrec - Coverage > Threshold,
    CoverageSucc - Coverage > Threshold,
%    !,
    Reason = sawtooth,
    concat_atom(['Reported data excluded due to decline in reported coverage from ',
		 CoverageSucc, ' percent to ', Coverage,
		 ' percent with increase to ', CoverageSucc,' percent. '], Expl).

% Reason to exclude reported: sudden change in most recently reported
% data for classic vaccines.
reported_reason_to_exclude(C, V, Y, Reason, Expl) :-
    not(member(V, [pcv3, rotac])),
    reported(C, V, Y, _, Coverage),
    not(workingGroupDecision(C, V, Y, acceptReported, _, _, _)),
    not(reported_later(C, V, Y)),
    Prec is Y - 1,
    reported(C, V, Prec, _, CoveragePrec),
    sawtooth_threshold(Threshold),
    abs(CoveragePrec - Coverage) > Threshold,
%    !,
    Reason = temporalChange,
    concat_atom(['Reported data excluded due to sudden change in coverage from ',
		 CoveragePrec, ' level to ', Coverage,' percent. '], Expl).

% Reason to exclude reported: sudden decline in most recently reported
% data for new vaccines.
reported_reason_to_exclude(C, V, Y, Reason, Expl) :-
    member(V, [pcv3, rotac]),
    reported(C, V, Y, _, Coverage),
    not(workingGroupDecision(C, V, Y, acceptReported, _, _, _)),
    not(reported_later(C, V, Y)),
    Prec is Y - 1,
    reported(C, V, Prec, _, CoveragePrec),
    sawtooth_threshold(Threshold),
    (CoveragePrec - Coverage) > Threshold,
%    !,
    Reason = temporalChange,
    concat_atom(['Reported data excluded due to decline in reported coverage from ',
		 CoveragePrec,' level to ', Coverage, ' percent. '], Expl).

reported_later(C, V, Y) :-
    between(Y, 2023, After),
    After > Y,
    reported(C, V, After, _, _).

% Reported to WHO and UNICEF is government estimate. If government
% estimate missing, then reported is administrative data. If both
% missing, fail.
%
% Semi-deterministic if Y is a variable. Needed for
% year_between_reported. Therefore, no cuts. Todo: make deterministic by
% fixing year_between_reported.
%
reported(C, V, Y, Source, Coverage) :-
    gov(C, V, Y, Cov0),
    not(workingGroupDecision(C, V, Y, ignoreGov, _, _, _)),
    !,
    Source = gov,
    Coverage = Cov0.

reported(C, V, Y, Source, Coverage) :-
    admin(C, V, Y, Cov0),
    (	workingGroupDecision(C, V, Y, ignoreGov, _, _, _)
    ;	not(gov(C, V, Y, _))
    ),
    not(workingGroupDecision(C, V, Y, ignoreAdmin, _, _, _)),
    !,
    Source = admin,
    Coverage = Cov0.

% Determine whether a working group decision applies for a given year if
% working group decision applies over an interval of time.
workingGroupDecision(C, V, Y, Action, Explanation, Survey, Coverage) :-
    wgd(C, V, Begin, End, Action, Explanation, Survey, Coverage, _, _),
    Begin =< Y, End >= Y.

% routines for interpolated points
year_between_reported(C, V, Y, YearBefore, CoverageBefore, YearAfter, CoverageAfter) :-
    year_before_reported(C, V, Y, YearBefore, CoverageBefore),
    year_after_reported(C, V, Y, YearAfter, CoverageAfter).

year_before_reported(C, V, Y, Before, Coverage) :-
    Dist is Y - 1997, % change to minimum from estimate_required
    between(1, Dist, Minus),
    Bef0 is Y - Minus,
    reported(C, V, Bef0, _, Cov0),
    not(reported_reason_to_exclude(C, V, Bef0, _, _)),
    !,
    Before = Bef0,
    Coverage = Cov0.

year_after_reported(C, V, Y, After, Coverage) :-
    between(Y, 2023, Aft0), % change to date(Date) or maximum from estimate_required
    Aft0 > Y,
    reported(C, V, Aft0, _, Cov0),
    not(reported_reason_to_exclude(C, V, Aft0, _, _)),
    !,
    After = Aft0,
    Coverage = Cov0.

% Extrapolation using nearest neighbor
nearest_reported(C, V, Y, Nearest, Coverage) :-
    year_before_reported(C, V, Y, Before, CoverageBefore),
    year_after_reported(C, V, Y, After, CoverageAfter),
    !,
    (	Y - Before < After - Y
    ->	Nearest = Before,
	Coverage = CoverageBefore
    ;	Nearest = After,
	Coverage = CoverageAfter
    ).

nearest_reported(C, V, Y, Nearest, Coverage) :-
    year_before_reported(C, V, Y, Before, CoverageBefore),
    !,
    Nearest = Before,
    Coverage = CoverageBefore.

nearest_reported(C, V, Y, Nearest, Coverage) :-
    year_after_reported(C, V, Y, After, CoverageAfter),
    !,
    Nearest = After,
    Coverage = CoverageAfter.

% Get values of nearest surrounding anchor points.
between_anchor_points(C, V, Y, Prec, PrecRule, PrecCov, Succ, SuccRule, SuccCov) :-
    prec_anchor_point(C, V, Y, Prec, PrecRule, PrecCov),
    succ_anchor_point(C, V, Y, Succ, SuccRule, SuccCov).

prec_anchor_point(C, V, Y, Prec, Rule, Coverage) :-
    Dist is Y - 1997, % change to minimum from estimate_required
    between(1, Dist, Minus),
    Prec0 is Y - Minus,
    anchor_point(C, V, Prec0, Rule0, _Expl0, Cov0),
    !,
    Prec = Prec0,
    Rule = Rule0,
    Coverage = Cov0.

succ_anchor_point(C, V, Y, Succ, Rule, Coverage) :-
    between(Y, 2023, Succ0),
    Succ0 > Y,
    anchor_point(C, V, Succ0, Rule0, _Expl0, Cov0),
    !,
    Succ = Succ0,
    Rule = Rule0,
    Coverage = Cov0.

% Interpolate between two years
interpolate(Prec, PrecCov, Succ, SuccCov, Year, Coverage) :-
    Slope is (SuccCov - PrecCov) / (Succ - Prec),
    Coverage is round(PrecCov + (Year - Prec) * Slope).

% Calibrate reported data to anchor points
% MG, issue: why are values rounded?
calibrate(C, V, Prec, Succ, Y, Coverage) :-
    reported_time_series(C, V, Prec, _, PrecRep),
    reported_time_series(C, V, Succ, _, SuccRep),
    anchor_point(C, V, Prec, _, _, PrecCov),
    anchor_point(C, V, Succ, _, _, SuccCov),
    !,
    reported_time_series(C, V, Y, _, Reported),
    interpolate(Prec, PrecRep, Succ, SuccRep, Y, RepInterp),
    interpolate(Prec, PrecCov, Succ, SuccCov, Y, AnchInterp),
    Adj is AnchInterp - RepInterp,
    Coverage is round(Reported + Adj).

% Reported data only at preceeding anchor
calibrate(C, V, Prec, _Succ, Y, Coverage) :-
    reported_time_series(C, V, Prec, _, PrecRep),
    anchor_point(C, V, Prec, _, _, PrecCov),
    !,
    reported_time_series(C, V, Y, _, Reported),
    Adj is PrecCov - PrecRep,
    Coverage is round(Reported + Adj).

calibrate(C, V, Prec, Succ, Y, _) :-
    throw(misc_error(calibrate(C, V, Prec, Succ, Y))).

% Ensure estimates are between 0 and 99 (MG, todo: round only at output)
bound_0_100(X, Y) :-
    Y is max(0, min(99, round(X))).

% Add underlying data to each C, V, Y estimate
collect_data(C, V, Y, Prev, Admin, Gov, Reported, Vaccinated,
        Target, Births, SI, Series, Source, Survey) :-
    legacy_estimate(C, V, Y, Prev),
    admin_data(C, V, Y, Admin),
    gov_data(C, V, Y, Gov),
    reported_data(C, V, Y, Reported),
    vaccinated_data(C, V, Y, Vaccinated),
    target_data(C, V, Y, Target),
    time_series_data(C, V, Y, Source, Series),
    unpd_births_data(C, Y, Births),
    unpd_si_data(C, Y, SI),
    survey_data(C, V, Y, Survey).

legacy_estimate(C, V, Y, Data) :-
    legacy(C, V, Y, Data0),
    !,
    Data = Data0.

legacy_estimate(_, _, _, '').

admin_data(C, V, Y, Data) :-
    admin(C, V, Y, Data0),
    !,
    Data = Data0.

admin_data(_, _, _, '').

gov_data(C, V, Y, Data) :-
    gov(C, V, Y, Data0),
    !,
    Data = Data0.

gov_data(_, _, _, '').

reported_data(C, V, Y, Data) :-
    reported(C, V, Y, _, Data0),
    !,
    Data = Data0.

reported_data(_, _, _, '').

vaccinated_data(C, V, Y, Data) :-
    vaccinated(C, V, Y, Data0),
    !,
    Data = Data0.

vaccinated_data(_, _, _, '').

target_data(C, V, Y, Data) :-
    target(C, V, Y, Data0),
    !,
    Data = Data0.

target_data(_, _, _, '').

unpd_births_data(C, Y, Data) :-
    births_UNPD(C, Y, Data0),
    !,
    Data = Data0.

unpd_births_data(_, _, '').

unpd_si_data(C, Y, Data) :-
    si_UNPD(C, Y, Data0),
    !,
    Data = Data0.

unpd_si_data(_, _, '').

time_series_data(C, V, Y, Source, Value) :-
    reported_time_series(C, V, Y, Source0, Value0),
    !,
    Source = Source0,
    Value = Value0.

time_series_data(_, _, _, '', '').

survey_data(C, V, Y, Data) :-
    survey(C, V, Y, _, Data0),
    !,
    Data = Data0.

survey_data(_, _, _, '').

% Collect explanations in natural language terms
collect_explanations(C, V, Y, Explanations) :-
    findall(Expl, explanation(C, V, Y, Expl), Explanations).

explanation(C, V, Y, Expl) :-
    survey_reason_to_exclude(C, V, Y, _, Expl).

explanation(C, V, Y, Expl) :-
    survey_results_modified(C, V, Y, _, Expl, _).

explanation(C, V, Y, Expl) :-
    reported_reason_to_exclude(C, V, Y, _, Expl).

explanation(C, V, Y, Expl) :-
    workingGroupDecision(C, V, Y, comment, Expl, _, _).

explanation(C, V, Y, Expl) :-
    workingGroupDecision(C, V, Y, acceptSurvey, Expl, _, _).

explanation(C, V, Y, Expl) :-
    workingGroupDecision(C, V, Y, acceptReported, Expl, _, _).

explanation(C, V, Y, Expl) :-
    workingGroupDecision(C, V, Y, ignoreGov, Expl, _, _).

open_out_file(Out,File,Header) :-
	open(File,write,Out),
	write(Out,Header),
	nl(Out).

output_results([],_).
output_results([H|T],Out) :- output_fields(H,Out), output_results(T,Out).

output_fields([],Out) :- nl(Out).
output_fields([H|T],Out) :- write(Out,H),write(Out,'\t'),output_fields(T,Out).
